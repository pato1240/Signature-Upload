{
  "_entries": [
    {
      "name": "signature_pad",
      "path": "/home/user/projects/c24c313/employees/node_modules/signature_pad/dist/signature_pad.js",
      "lastModified": 1744458926459,
      "type": "module",
      "code": "sap.ui.define((function () { 'use strict';\n\n    /*!\n     * Signature Pad v5.0.4 | https://github.com/szimek/signature_pad\n     * (c) 2024 Szymon Nowak | Released under the MIT license\n     */\n\n    class Point {\n        constructor(x, y, pressure, time) {\n            if (isNaN(x) || isNaN(y)) {\n                throw new Error(`Point is invalid: (${x}, ${y})`);\n            }\n            this.x = +x;\n            this.y = +y;\n            this.pressure = pressure || 0;\n            this.time = time || Date.now();\n        }\n        distanceTo(start) {\n            return Math.sqrt(Math.pow(this.x - start.x, 2) + Math.pow(this.y - start.y, 2));\n        }\n        equals(other) {\n            return (this.x === other.x &&\n                this.y === other.y &&\n                this.pressure === other.pressure &&\n                this.time === other.time);\n        }\n        velocityFrom(start) {\n            return this.time !== start.time\n                ? this.distanceTo(start) / (this.time - start.time)\n                : 0;\n        }\n    }\n\n    class Bezier {\n        static fromPoints(points, widths) {\n            const c2 = this.calculateControlPoints(points[0], points[1], points[2]).c2;\n            const c3 = this.calculateControlPoints(points[1], points[2], points[3]).c1;\n            return new Bezier(points[1], c2, c3, points[2], widths.start, widths.end);\n        }\n        static calculateControlPoints(s1, s2, s3) {\n            const dx1 = s1.x - s2.x;\n            const dy1 = s1.y - s2.y;\n            const dx2 = s2.x - s3.x;\n            const dy2 = s2.y - s3.y;\n            const m1 = { x: (s1.x + s2.x) / 2.0, y: (s1.y + s2.y) / 2.0 };\n            const m2 = { x: (s2.x + s3.x) / 2.0, y: (s2.y + s3.y) / 2.0 };\n            const l1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);\n            const l2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);\n            const dxm = m1.x - m2.x;\n            const dym = m1.y - m2.y;\n            const k = l1 + l2 == 0 ? 0 : l2 / (l1 + l2);\n            const cm = { x: m2.x + dxm * k, y: m2.y + dym * k };\n            const tx = s2.x - cm.x;\n            const ty = s2.y - cm.y;\n            return {\n                c1: new Point(m1.x + tx, m1.y + ty),\n                c2: new Point(m2.x + tx, m2.y + ty),\n            };\n        }\n        constructor(startPoint, control2, control1, endPoint, startWidth, endWidth) {\n            this.startPoint = startPoint;\n            this.control2 = control2;\n            this.control1 = control1;\n            this.endPoint = endPoint;\n            this.startWidth = startWidth;\n            this.endWidth = endWidth;\n        }\n        length() {\n            const steps = 10;\n            let length = 0;\n            let px;\n            let py;\n            for (let i = 0; i <= steps; i += 1) {\n                const t = i / steps;\n                const cx = this.point(t, this.startPoint.x, this.control1.x, this.control2.x, this.endPoint.x);\n                const cy = this.point(t, this.startPoint.y, this.control1.y, this.control2.y, this.endPoint.y);\n                if (i > 0) {\n                    const xdiff = cx - px;\n                    const ydiff = cy - py;\n                    length += Math.sqrt(xdiff * xdiff + ydiff * ydiff);\n                }\n                px = cx;\n                py = cy;\n            }\n            return length;\n        }\n        point(t, start, c1, c2, end) {\n            return (start * (1.0 - t) * (1.0 - t) * (1.0 - t))\n                + (3.0 * c1 * (1.0 - t) * (1.0 - t) * t)\n                + (3.0 * c2 * (1.0 - t) * t * t)\n                + (end * t * t * t);\n        }\n    }\n\n    class SignatureEventTarget {\n        constructor() {\n            try {\n                this._et = new EventTarget();\n            }\n            catch (_a) {\n                this._et = document;\n            }\n        }\n        addEventListener(type, listener, options) {\n            this._et.addEventListener(type, listener, options);\n        }\n        dispatchEvent(event) {\n            return this._et.dispatchEvent(event);\n        }\n        removeEventListener(type, callback, options) {\n            this._et.removeEventListener(type, callback, options);\n        }\n    }\n\n    function throttle(fn, wait = 250) {\n        let previous = 0;\n        let timeout = null;\n        let result;\n        let storedContext;\n        let storedArgs;\n        const later = () => {\n            previous = Date.now();\n            timeout = null;\n            result = fn.apply(storedContext, storedArgs);\n            if (!timeout) {\n                storedContext = null;\n                storedArgs = [];\n            }\n        };\n        return function wrapper(...args) {\n            const now = Date.now();\n            const remaining = wait - (now - previous);\n            storedContext = this;\n            storedArgs = args;\n            if (remaining <= 0 || remaining > wait) {\n                if (timeout) {\n                    clearTimeout(timeout);\n                    timeout = null;\n                }\n                previous = now;\n                result = fn.apply(storedContext, storedArgs);\n                if (!timeout) {\n                    storedContext = null;\n                    storedArgs = [];\n                }\n            }\n            else if (!timeout) {\n                timeout = window.setTimeout(later, remaining);\n            }\n            return result;\n        };\n    }\n\n    class SignaturePad extends SignatureEventTarget {\n        constructor(canvas, options = {}) {\n            var _a, _b, _c;\n            super();\n            this.canvas = canvas;\n            this._drawingStroke = false;\n            this._isEmpty = true;\n            this._lastPoints = [];\n            this._data = [];\n            this._lastVelocity = 0;\n            this._lastWidth = 0;\n            this._handleMouseDown = (event) => {\n                if (!this._isLeftButtonPressed(event, true) || this._drawingStroke) {\n                    return;\n                }\n                this._strokeBegin(this._pointerEventToSignatureEvent(event));\n            };\n            this._handleMouseMove = (event) => {\n                if (!this._isLeftButtonPressed(event, true) || !this._drawingStroke) {\n                    this._strokeEnd(this._pointerEventToSignatureEvent(event), false);\n                    return;\n                }\n                this._strokeMoveUpdate(this._pointerEventToSignatureEvent(event));\n            };\n            this._handleMouseUp = (event) => {\n                if (this._isLeftButtonPressed(event)) {\n                    return;\n                }\n                this._strokeEnd(this._pointerEventToSignatureEvent(event));\n            };\n            this._handleTouchStart = (event) => {\n                if (event.targetTouches.length !== 1 || this._drawingStroke) {\n                    return;\n                }\n                if (event.cancelable) {\n                    event.preventDefault();\n                }\n                this._strokeBegin(this._touchEventToSignatureEvent(event));\n            };\n            this._handleTouchMove = (event) => {\n                if (event.targetTouches.length !== 1) {\n                    return;\n                }\n                if (event.cancelable) {\n                    event.preventDefault();\n                }\n                if (!this._drawingStroke) {\n                    this._strokeEnd(this._touchEventToSignatureEvent(event), false);\n                    return;\n                }\n                this._strokeMoveUpdate(this._touchEventToSignatureEvent(event));\n            };\n            this._handleTouchEnd = (event) => {\n                if (event.targetTouches.length !== 0) {\n                    return;\n                }\n                if (event.cancelable) {\n                    event.preventDefault();\n                }\n                this.canvas.removeEventListener('touchmove', this._handleTouchMove);\n                this._strokeEnd(this._touchEventToSignatureEvent(event));\n            };\n            this._handlePointerDown = (event) => {\n                if (!event.isPrimary || !this._isLeftButtonPressed(event) || this._drawingStroke) {\n                    return;\n                }\n                event.preventDefault();\n                this._strokeBegin(this._pointerEventToSignatureEvent(event));\n            };\n            this._handlePointerMove = (event) => {\n                if (!event.isPrimary) {\n                    return;\n                }\n                if (!this._isLeftButtonPressed(event, true) || !this._drawingStroke) {\n                    this._strokeEnd(this._pointerEventToSignatureEvent(event), false);\n                    return;\n                }\n                event.preventDefault();\n                this._strokeMoveUpdate(this._pointerEventToSignatureEvent(event));\n            };\n            this._handlePointerUp = (event) => {\n                if (!event.isPrimary || this._isLeftButtonPressed(event)) {\n                    return;\n                }\n                event.preventDefault();\n                this._strokeEnd(this._pointerEventToSignatureEvent(event));\n            };\n            this.velocityFilterWeight = options.velocityFilterWeight || 0.7;\n            this.minWidth = options.minWidth || 0.5;\n            this.maxWidth = options.maxWidth || 2.5;\n            this.throttle = (_a = options.throttle) !== null && _a !== void 0 ? _a : 16;\n            this.minDistance = (_b = options.minDistance) !== null && _b !== void 0 ? _b : 5;\n            this.dotSize = options.dotSize || 0;\n            this.penColor = options.penColor || 'black';\n            this.backgroundColor = options.backgroundColor || 'rgba(0,0,0,0)';\n            this.compositeOperation = options.compositeOperation || 'source-over';\n            this.canvasContextOptions = (_c = options.canvasContextOptions) !== null && _c !== void 0 ? _c : {};\n            this._strokeMoveUpdate = this.throttle\n                ? throttle(SignaturePad.prototype._strokeUpdate, this.throttle)\n                : SignaturePad.prototype._strokeUpdate;\n            this._ctx = canvas.getContext('2d', this.canvasContextOptions);\n            this.clear();\n            this.on();\n        }\n        clear() {\n            const { _ctx: ctx, canvas } = this;\n            ctx.fillStyle = this.backgroundColor;\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n            this._data = [];\n            this._reset(this._getPointGroupOptions());\n            this._isEmpty = true;\n        }\n        fromDataURL(dataUrl, options = {}) {\n            return new Promise((resolve, reject) => {\n                const image = new Image();\n                const ratio = options.ratio || window.devicePixelRatio || 1;\n                const width = options.width || this.canvas.width / ratio;\n                const height = options.height || this.canvas.height / ratio;\n                const xOffset = options.xOffset || 0;\n                const yOffset = options.yOffset || 0;\n                this._reset(this._getPointGroupOptions());\n                image.onload = () => {\n                    this._ctx.drawImage(image, xOffset, yOffset, width, height);\n                    resolve();\n                };\n                image.onerror = (error) => {\n                    reject(error);\n                };\n                image.crossOrigin = 'anonymous';\n                image.src = dataUrl;\n                this._isEmpty = false;\n            });\n        }\n        toDataURL(type = 'image/png', encoderOptions) {\n            switch (type) {\n                case 'image/svg+xml':\n                    if (typeof encoderOptions !== 'object') {\n                        encoderOptions = undefined;\n                    }\n                    return `data:image/svg+xml;base64,${btoa(this.toSVG(encoderOptions))}`;\n                default:\n                    if (typeof encoderOptions !== 'number') {\n                        encoderOptions = undefined;\n                    }\n                    return this.canvas.toDataURL(type, encoderOptions);\n            }\n        }\n        on() {\n            this.canvas.style.touchAction = 'none';\n            this.canvas.style.msTouchAction = 'none';\n            this.canvas.style.userSelect = 'none';\n            const isIOS = /Macintosh/.test(navigator.userAgent) && 'ontouchstart' in document;\n            if (window.PointerEvent && !isIOS) {\n                this._handlePointerEvents();\n            }\n            else {\n                this._handleMouseEvents();\n                if ('ontouchstart' in window) {\n                    this._handleTouchEvents();\n                }\n            }\n        }\n        off() {\n            this.canvas.style.touchAction = 'auto';\n            this.canvas.style.msTouchAction = 'auto';\n            this.canvas.style.userSelect = 'auto';\n            this.canvas.removeEventListener('pointerdown', this._handlePointerDown);\n            this.canvas.removeEventListener('mousedown', this._handleMouseDown);\n            this.canvas.removeEventListener('touchstart', this._handleTouchStart);\n            this._removeMoveUpEventListeners();\n        }\n        _getListenerFunctions() {\n            var _a;\n            const canvasWindow = window.document === this.canvas.ownerDocument\n                ? window\n                : (_a = this.canvas.ownerDocument.defaultView) !== null && _a !== void 0 ? _a : this.canvas.ownerDocument;\n            return {\n                addEventListener: canvasWindow.addEventListener.bind(canvasWindow),\n                removeEventListener: canvasWindow.removeEventListener.bind(canvasWindow),\n            };\n        }\n        _removeMoveUpEventListeners() {\n            const { removeEventListener } = this._getListenerFunctions();\n            removeEventListener('pointermove', this._handlePointerMove);\n            removeEventListener('pointerup', this._handlePointerUp);\n            removeEventListener('mousemove', this._handleMouseMove);\n            removeEventListener('mouseup', this._handleMouseUp);\n            removeEventListener('touchmove', this._handleTouchMove);\n            removeEventListener('touchend', this._handleTouchEnd);\n        }\n        isEmpty() {\n            return this._isEmpty;\n        }\n        fromData(pointGroups, { clear = true } = {}) {\n            if (clear) {\n                this.clear();\n            }\n            this._fromData(pointGroups, this._drawCurve.bind(this), this._drawDot.bind(this));\n            this._data = this._data.concat(pointGroups);\n        }\n        toData() {\n            return this._data;\n        }\n        _isLeftButtonPressed(event, only) {\n            if (only) {\n                return event.buttons === 1;\n            }\n            return (event.buttons & 1) === 1;\n        }\n        _pointerEventToSignatureEvent(event) {\n            return {\n                event: event,\n                type: event.type,\n                x: event.clientX,\n                y: event.clientY,\n                pressure: 'pressure' in event ? event.pressure : 0,\n            };\n        }\n        _touchEventToSignatureEvent(event) {\n            const touch = event.changedTouches[0];\n            return {\n                event: event,\n                type: event.type,\n                x: touch.clientX,\n                y: touch.clientY,\n                pressure: touch.force,\n            };\n        }\n        _getPointGroupOptions(group) {\n            return {\n                penColor: group && 'penColor' in group ? group.penColor : this.penColor,\n                dotSize: group && 'dotSize' in group ? group.dotSize : this.dotSize,\n                minWidth: group && 'minWidth' in group ? group.minWidth : this.minWidth,\n                maxWidth: group && 'maxWidth' in group ? group.maxWidth : this.maxWidth,\n                velocityFilterWeight: group && 'velocityFilterWeight' in group\n                    ? group.velocityFilterWeight\n                    : this.velocityFilterWeight,\n                compositeOperation: group && 'compositeOperation' in group\n                    ? group.compositeOperation\n                    : this.compositeOperation,\n            };\n        }\n        _strokeBegin(event) {\n            const cancelled = !this.dispatchEvent(new CustomEvent('beginStroke', { detail: event, cancelable: true }));\n            if (cancelled) {\n                return;\n            }\n            const { addEventListener } = this._getListenerFunctions();\n            switch (event.event.type) {\n                case 'mousedown':\n                    addEventListener('mousemove', this._handleMouseMove);\n                    addEventListener('mouseup', this._handleMouseUp);\n                    break;\n                case 'touchstart':\n                    addEventListener('touchmove', this._handleTouchMove);\n                    addEventListener('touchend', this._handleTouchEnd);\n                    break;\n                case 'pointerdown':\n                    addEventListener('pointermove', this._handlePointerMove);\n                    addEventListener('pointerup', this._handlePointerUp);\n                    break;\n            }\n            this._drawingStroke = true;\n            const pointGroupOptions = this._getPointGroupOptions();\n            const newPointGroup = Object.assign(Object.assign({}, pointGroupOptions), { points: [] });\n            this._data.push(newPointGroup);\n            this._reset(pointGroupOptions);\n            this._strokeUpdate(event);\n        }\n        _strokeUpdate(event) {\n            if (!this._drawingStroke) {\n                return;\n            }\n            if (this._data.length === 0) {\n                this._strokeBegin(event);\n                return;\n            }\n            this.dispatchEvent(new CustomEvent('beforeUpdateStroke', { detail: event }));\n            const point = this._createPoint(event.x, event.y, event.pressure);\n            const lastPointGroup = this._data[this._data.length - 1];\n            const lastPoints = lastPointGroup.points;\n            const lastPoint = lastPoints.length > 0 && lastPoints[lastPoints.length - 1];\n            const isLastPointTooClose = lastPoint\n                ? point.distanceTo(lastPoint) <= this.minDistance\n                : false;\n            const pointGroupOptions = this._getPointGroupOptions(lastPointGroup);\n            if (!lastPoint || !(lastPoint && isLastPointTooClose)) {\n                const curve = this._addPoint(point, pointGroupOptions);\n                if (!lastPoint) {\n                    this._drawDot(point, pointGroupOptions);\n                }\n                else if (curve) {\n                    this._drawCurve(curve, pointGroupOptions);\n                }\n                lastPoints.push({\n                    time: point.time,\n                    x: point.x,\n                    y: point.y,\n                    pressure: point.pressure,\n                });\n            }\n            this.dispatchEvent(new CustomEvent('afterUpdateStroke', { detail: event }));\n        }\n        _strokeEnd(event, shouldUpdate = true) {\n            this._removeMoveUpEventListeners();\n            if (!this._drawingStroke) {\n                return;\n            }\n            if (shouldUpdate) {\n                this._strokeUpdate(event);\n            }\n            this._drawingStroke = false;\n            this.dispatchEvent(new CustomEvent('endStroke', { detail: event }));\n        }\n        _handlePointerEvents() {\n            this._drawingStroke = false;\n            this.canvas.addEventListener('pointerdown', this._handlePointerDown);\n        }\n        _handleMouseEvents() {\n            this._drawingStroke = false;\n            this.canvas.addEventListener('mousedown', this._handleMouseDown);\n        }\n        _handleTouchEvents() {\n            this.canvas.addEventListener('touchstart', this._handleTouchStart);\n        }\n        _reset(options) {\n            this._lastPoints = [];\n            this._lastVelocity = 0;\n            this._lastWidth = (options.minWidth + options.maxWidth) / 2;\n            this._ctx.fillStyle = options.penColor;\n            this._ctx.globalCompositeOperation = options.compositeOperation;\n        }\n        _createPoint(x, y, pressure) {\n            const rect = this.canvas.getBoundingClientRect();\n            return new Point(x - rect.left, y - rect.top, pressure, new Date().getTime());\n        }\n        _addPoint(point, options) {\n            const { _lastPoints } = this;\n            _lastPoints.push(point);\n            if (_lastPoints.length > 2) {\n                if (_lastPoints.length === 3) {\n                    _lastPoints.unshift(_lastPoints[0]);\n                }\n                const widths = this._calculateCurveWidths(_lastPoints[1], _lastPoints[2], options);\n                const curve = Bezier.fromPoints(_lastPoints, widths);\n                _lastPoints.shift();\n                return curve;\n            }\n            return null;\n        }\n        _calculateCurveWidths(startPoint, endPoint, options) {\n            const velocity = options.velocityFilterWeight * endPoint.velocityFrom(startPoint) +\n                (1 - options.velocityFilterWeight) * this._lastVelocity;\n            const newWidth = this._strokeWidth(velocity, options);\n            const widths = {\n                end: newWidth,\n                start: this._lastWidth,\n            };\n            this._lastVelocity = velocity;\n            this._lastWidth = newWidth;\n            return widths;\n        }\n        _strokeWidth(velocity, options) {\n            return Math.max(options.maxWidth / (velocity + 1), options.minWidth);\n        }\n        _drawCurveSegment(x, y, width) {\n            const ctx = this._ctx;\n            ctx.moveTo(x, y);\n            ctx.arc(x, y, width, 0, 2 * Math.PI, false);\n            this._isEmpty = false;\n        }\n        _drawCurve(curve, options) {\n            const ctx = this._ctx;\n            const widthDelta = curve.endWidth - curve.startWidth;\n            const drawSteps = Math.ceil(curve.length()) * 2;\n            ctx.beginPath();\n            ctx.fillStyle = options.penColor;\n            for (let i = 0; i < drawSteps; i += 1) {\n                const t = i / drawSteps;\n                const tt = t * t;\n                const ttt = tt * t;\n                const u = 1 - t;\n                const uu = u * u;\n                const uuu = uu * u;\n                let x = uuu * curve.startPoint.x;\n                x += 3 * uu * t * curve.control1.x;\n                x += 3 * u * tt * curve.control2.x;\n                x += ttt * curve.endPoint.x;\n                let y = uuu * curve.startPoint.y;\n                y += 3 * uu * t * curve.control1.y;\n                y += 3 * u * tt * curve.control2.y;\n                y += ttt * curve.endPoint.y;\n                const width = Math.min(curve.startWidth + ttt * widthDelta, options.maxWidth);\n                this._drawCurveSegment(x, y, width);\n            }\n            ctx.closePath();\n            ctx.fill();\n        }\n        _drawDot(point, options) {\n            const ctx = this._ctx;\n            const width = options.dotSize > 0\n                ? options.dotSize\n                : (options.minWidth + options.maxWidth) / 2;\n            ctx.beginPath();\n            this._drawCurveSegment(point.x, point.y, width);\n            ctx.closePath();\n            ctx.fillStyle = options.penColor;\n            ctx.fill();\n        }\n        _fromData(pointGroups, drawCurve, drawDot) {\n            for (const group of pointGroups) {\n                const { points } = group;\n                const pointGroupOptions = this._getPointGroupOptions(group);\n                if (points.length > 1) {\n                    for (let j = 0; j < points.length; j += 1) {\n                        const basicPoint = points[j];\n                        const point = new Point(basicPoint.x, basicPoint.y, basicPoint.pressure, basicPoint.time);\n                        if (j === 0) {\n                            this._reset(pointGroupOptions);\n                        }\n                        const curve = this._addPoint(point, pointGroupOptions);\n                        if (curve) {\n                            drawCurve(curve, pointGroupOptions);\n                        }\n                    }\n                }\n                else {\n                    this._reset(pointGroupOptions);\n                    drawDot(points[0], pointGroupOptions);\n                }\n            }\n        }\n        toSVG({ includeBackgroundColor = false } = {}) {\n            const pointGroups = this._data;\n            const ratio = Math.max(window.devicePixelRatio || 1, 1);\n            const minX = 0;\n            const minY = 0;\n            const maxX = this.canvas.width / ratio;\n            const maxY = this.canvas.height / ratio;\n            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n            svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');\n            svg.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');\n            svg.setAttribute('viewBox', `${minX} ${minY} ${maxX} ${maxY}`);\n            svg.setAttribute('width', maxX.toString());\n            svg.setAttribute('height', maxY.toString());\n            if (includeBackgroundColor && this.backgroundColor) {\n                const rect = document.createElement('rect');\n                rect.setAttribute('width', '100%');\n                rect.setAttribute('height', '100%');\n                rect.setAttribute('fill', this.backgroundColor);\n                svg.appendChild(rect);\n            }\n            this._fromData(pointGroups, (curve, { penColor }) => {\n                const path = document.createElement('path');\n                if (!isNaN(curve.control1.x) &&\n                    !isNaN(curve.control1.y) &&\n                    !isNaN(curve.control2.x) &&\n                    !isNaN(curve.control2.y)) {\n                    const attr = `M ${curve.startPoint.x.toFixed(3)},${curve.startPoint.y.toFixed(3)} ` +\n                        `C ${curve.control1.x.toFixed(3)},${curve.control1.y.toFixed(3)} ` +\n                        `${curve.control2.x.toFixed(3)},${curve.control2.y.toFixed(3)} ` +\n                        `${curve.endPoint.x.toFixed(3)},${curve.endPoint.y.toFixed(3)}`;\n                    path.setAttribute('d', attr);\n                    path.setAttribute('stroke-width', (curve.endWidth * 2.25).toFixed(3));\n                    path.setAttribute('stroke', penColor);\n                    path.setAttribute('fill', 'none');\n                    path.setAttribute('stroke-linecap', 'round');\n                    svg.appendChild(path);\n                }\n            }, (point, { penColor, dotSize, minWidth, maxWidth }) => {\n                const circle = document.createElement('circle');\n                const size = dotSize > 0 ? dotSize : (minWidth + maxWidth) / 2;\n                circle.setAttribute('r', size.toString());\n                circle.setAttribute('cx', point.x.toString());\n                circle.setAttribute('cy', point.y.toString());\n                circle.setAttribute('fill', penColor);\n                svg.appendChild(circle);\n            });\n            return svg.outerHTML;\n        }\n    }\n\n    let exp = SignaturePad?.default || SignaturePad || { __emptyModule: true };try { Object.defineProperty(exp, \"__\" + \"esModule\", { value: true }); exp.default = exp; } catch (ex) {}\n\n    return exp;\n\n}));\n"
    }
  ]
}